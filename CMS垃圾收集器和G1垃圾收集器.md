### CMS垃圾收集器和G1垃圾收集器

虚拟机中垃圾收集器分为串行和并行。

串行：垃圾收集器和用户程序交替执行

并行：垃圾收集器和用户程序同时执行

除了CMS和G1以外，所有垃圾收集器都是串行

#### CMS垃圾收集器（Concurrent Mark Sweep）：并发标记清除垃圾收集器。

分为五个流程：

**初始标记**：需要停顿，只标记跟GC Roots直接关联的对象

**并发标记**：标记所有跟GC Roots关联的对象

**重新标记**：需要停顿，因为在并发标记过程中，程序执行可能会改变对象引用关系，因此需要重新标记这部分对象

**并发清除**：并发地清除被标记地需要清楚的对象

**并发重置**：重置CMS维护的数据结构。因为标记清除会产生内存碎片，为了减少空间浪费，CMS维护了一个空闲空间的列表，每次对象晋升后从列表中搜索最符合对象地内存空间进行分配。因此每次并发清除后，需要更新CMS维护的空闲空间列表。

#### G1垃圾收集器（Garbage-First）：垃圾优先垃圾收集器？

​	它是为了替换CMS而开发的。因为CMS在进行标记时需要STW（停顿），如果堆内存很大，那么停顿的时间就会很长，为了减少停顿时间以及避免空间碎片，产生了G1。

​	其他垃圾收集器都是要么只回收新生代，要么只回收老年代，G1垃圾收集器可以对新生代和老年代一起回收。

​	G1垃圾收集器引入了Region（区域）的概念。不再将堆空间按照新生代老年代进行划分，而是将堆空间分为2048（默认）个等大的区域，这些区域有属于Eden、Old、Survivor等，每个小空间可以单独进行垃圾回收。每次进行垃圾回收时，只回收几个区域，以此来控制STW（停顿）的时间。通过记录每个Region每次垃圾回收的时间和释放的空间，维护一个优先列表，每次回收排名靠前的Region。

​	每个Region维护了一个Rset集合，Rset存的是Region引用对象的情况，这样每次进行可达性分析时，就不需要对整个堆扫描。

G1垃圾收集分为四个周期：

##### 年轻代收集周期：

​	所有eden区域都是空，开始创建对象，一个eden区域满了就放到另外一个，直到所有Eden区域都满了，然后触发年轻代收集，它使用单eden，双survivor进行复制算法。它将存活的对象从eden分区转移到survivor分区，survivor分区内的某些对象达到了任期阈值之后，会晋升到老年代分区中。原有的年轻代分区会被整个回收掉

##### 并发标记周期：

​	当越来越多对象晋升到老年代后，达到一定阈值（IOP）后，开始执行并发标记

初始标记：需要停顿，收集所有GC根对象，标记所有survivor区间的对象引用。（年轻代）

并发标记：标记所有存活对象。

重新标记：需要停顿，完成所有标记工作（并发标记过程程序执行可能会造成对象引用改变，因此需要停顿再标记）。

清除：回收没有存活对象的Region并加入可用Region队列

##### 混合收集周期：

​	与年轻代收集类似，因为包含老年代，所以叫混合收集。

##### Full GC周期：

​	两个情况同时满足触发：

1. 晋升对象无法在老年代找到足够大的内存空间。或者分配巨型对象找不到足够大的内存空间。
2. 当第一个情况发生，G1会尝试扩展堆，如果扩展失败，则触发full GC。